<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Portofino</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <style>
    #map {
      height: 95vh;
      width: 95vw;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div id="map"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <script>
    // Dimensiones originales del SVG
    const originalWidth = 3000;
    const originalHeight = 1053;

    // Crear el mapa en CRS simple
    const map = L.map('map', {
      crs: L.CRS.Simple,
      zoomSnap: 0.5,
      minZoom: -5
    });

    const bounds = [[0, 0], [originalHeight, originalWidth]];
    map.fitBounds(bounds);

    // URL del SVG (la misma que usabas para imageOverlay)
    const svgUrl = 'https://sarif-arg.github.io/plano_portofino.svg';

    // Cargamos el SVG como texto -> lo parseamos -> lo montamos como SVG real
    fetch(svgUrl)
      .then(r => r.text())
      .then(txt => {
        const parser = new DOMParser();
        const doc = parser.parseFromString(txt, 'image/svg+xml');
        const svgEl = doc.documentElement;

        // Aseguramos que el overlay se estire a los bounds sin deformaciones raras
        svgEl.setAttribute('viewBox', `0 0 ${originalWidth} ${originalHeight}`);
        svgEl.setAttribute('preserveAspectRatio', 'none');

        // Montamos el SVG como overlay interactivo
        const overlay = L.svgOverlay(svgEl, bounds).addTo(map);

        overlay.on('add', () => {
          const root = overlay.getElement(); // <svg> montado
          // Seleccionamos posibles figuras de lotes (ajustá el selector si usás otra etiqueta/clase)
          const terrenos = root.querySelectorAll('polygon, path, rect');

          terrenos.forEach(el => {
            el.style.cursor = 'pointer';

            // Hover: leve resaltado del borde
            el.addEventListener('mouseenter', () => {
              el.dataset._oldStroke = el.getAttribute('stroke') || '';
              el.dataset._oldStrokeWidth = el.getAttribute('stroke-width') || '';
              el.setAttribute('stroke', '#111');
              el.setAttribute('stroke-width', '2');
            });
            el.addEventListener('mouseleave', () => {
              if (el.dataset._oldStroke !== undefined) el.setAttribute('stroke', el.dataset._oldStroke);
              if (el.dataset._oldStrokeWidth !== undefined) el.setAttribute('stroke-width', el.dataset._oldStrokeWidth);
            });

            // Click: abrimos popup con info básica
            el.addEventListener('click', (ev) => {
              const id = el.getAttribute('id') || '—';
              const medidas = el.getAttribute('data-medidas') || '—';

              const fillColor = getFillColor(el);
              const estado = estadoDesdeFill(fillColor);

              // Convertimos posición del mouse a latlng del mapa
              const rect = map.getContainer().getBoundingClientRect();
              const containerPt = L.point(ev.clientX - rect.left, ev.clientY - rect.top);
              const latlng = map.containerPointToLatLng(containerPt);

              L.popup({ autoPan: true })
                .setLatLng(latlng)
                .setContent(`
                  <div style="min-width:240px; font-family: system-ui, -apple-system, Segoe UI, Roboto, 'Helvetica Neue', Arial;">
                    <div style="font-weight:700; margin-bottom:6px;">Terreno ${escapeHTML(id)}</div>
                    <div><strong>Medidas:</strong> ${escapeHTML(medidas)}</div>
                    <div><strong>Estado:</strong> ${estado}
                      <span style="display:inline-block;width:10px;height:10px;background:${fillColor};border:1px solid #666;margin-left:6px;vertical-align:middle;"></span>
                    </div>
                    <!-- Próximo paso: traer precio desde datos.json usando el ID -->
                  </div>
                `)
                .openOn(map);
            });
          });
        });
      })
      .catch(err => {
        console.error('Error cargando SVG:', err);
      });

    // Helpers
    function getFillColor(el) {
      // 1) atributo fill directo
      let fill = el.getAttribute('fill');
      // 2) estilo inline
      if (!fill || fill === 'none') fill = el.style.fill;
      // 3) estilo computado (si hubiera <style> dentro del SVG)
      if ((!fill || fill === 'none') && window.getComputedStyle) {
        try { fill = getComputedStyle(el).fill; } catch (e) {}
      }
      // Valor de fallback
      if (!fill || fill === 'none') fill = '#cccccc';
      return fill;
    }

    function estadoDesdeFill(fill) {
      const f = (fill || '').toLowerCase().replace(/\s/g, '');
      if (f.includes('green') || f.includes('#00ff00') || f.includes('0,255,0')) return 'Disponible';
      if (f.includes('yellow') || f.includes('#ffff00') || f.includes('255,255,0')) return 'Reservado';
      if (f.includes('red') || f.includes('#ff0000') || f.includes('255,0,0')) return 'Vendido';
      // Si usás otras paletas (pasteles custom), ajustamos acá los hex exactos:
      if (f.includes('#c6f6d5')) return 'Disponible'; // ej. verde pastel
      if (f.includes('#fef3c7')) return 'Reservado';  // ej. amarillo pastel
      if (f.includes('#fecaca')) return 'Vendido';    // ej. rojo pastel
      return 'Desconocido';
    }

    function escapeHTML(str) {
      return String(str).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;', "'":'&#39;'}[c]));
    }
  </script>
</body>
</html>
